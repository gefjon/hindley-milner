(uiop:define-package :hindley-milner/syntax
  (:nicknames :syntax)
  (:use :hindley-milner/defenum :trivial-types :cl)
  (:shadow :funcall :lambda :let :quote :if :binop)
  (:import-from :alexandria)
  (:export

   :literal
   :operator

   :definition :make-definition :definition-binding :definition-value

   :clause
   :funcall :make-funcall :funcall-function :funcall-args
   :lambda :make-lambda :lambda-bindings :lambda-body
   :let :make-let :let-bindings :let-body
   :if :make-if :if-predicate :if-then-case :if-else-case
   :binop :make-binop :binop-op :binop-lhs :binop-rhs

   :program :make-program :program-definitions :program-entry))
(cl:in-package :hindley-milner/syntax)

;;;; surface-level syntax, which largely mimics common lisp
;; TODO: write a parser that reads these out of s-exps

(defenum literal fixnum boolean)
(deftype operator ()
  '(member + - * / =))

(gefjon-utils:defstruct definition
  ((binding symbol)
   (value clause)))

(defenum clause
  symbol
  literal
  (funcall ((function clause)
            (args (proper-list clause))))
  (lambda ((bindings (proper-list symbol))
           (body (proper-list clause))))
  (let ((bindings (proper-list definition))
        (body (proper-list clause))))
  (if ((predicate clause)
       (then-case clause)
       (else-case clause)))
  (binop ((op operator)
          (lhs clause)
          (rhs clause))))

(defun parse (thing)
  (etypecase thing
    ((or symbol literal) thing)
    (cons (apply #'parse-list thing))))

(defun parse-body (body)
  (mapcar #'parse body))

(defgeneric parse-list (head &rest stuff)
  (:documentation "intended to be `CL:APPLY'ed to a `TRIVIAL-TYPES:PROPER-LIST'"))

(defmacro defparse (head lambda-list &body body)
  "define a parser for lists starting with HEAD and continuing with LAMBDA-LIST

e.g. (defparse funcall (function &rest args)
  (make-funcall (parse function)
                (mapcar #'parse args)))"
  (alexandria:with-gensyms (head-arg stuff-arg)
    `(defmethod parse-list ((,head-arg (eql ',head)) &rest ,stuff-arg)
       (declare (ignorable ,head-arg))
       ,(format nil "parser for ~s generated by `HINDLEY-MILNER/SYNTAX:DEFPARSE'" head)
       (destructuring-bind ,lambda-list ,stuff-arg
         ,@body))))

(defparse funcall (function &rest args)
  (make-funcall (parse function)
                (parse-body args)))

(defparse lambda (lambda-list &body body)
  (flet ((check-symbol (symbol)
           (unless (typep symbol 'symbol)
             (error "non-symbol ~s in `LAMBDA-LIST'" symbol))))
    (make-lambda (mapc #'check-symbol lambda-list)
                 (parse-body body))))

(defparse let (bindings &body body)
  (flet ((parse-binding (binding)
           (destructuring-bind (symbol value) binding
             (check-type symbol symbol)
             (make-definition symbol (parse value)))))
    (make-let (mapcar #'parse-binding bindings)
              (parse-body body))))

(defparse if (predicate then-clause else-clause)
  (make-if (parse predicate)
           (parse then-clause)
           (parse else-clause)))

(defparse binop (op lhs rhs)
  (check-type op operator)
  (make-binop op (parse lhs) (parse rhs)))

(gefjon-utils:defstruct program
  ((definitions (proper-list definition))
   (entry clause)))
