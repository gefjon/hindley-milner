(uiop:define-package :hindley-milner/subst
    (:mix :hindley-milner/prologue :cl)
  (:import-from :alexandria :make-gensym)
  (:import-from :gefjon-utils
   :symbol-concatenate
   :shallow-copy)
  (:nicknames :subst)
  (:shadow :subst)
  (:export :subst :define-subst :recurse :recurse-on-slots))
(cl:in-package :hindley-milner/subst)

(defgeneric subst-recurse (new old tree test)
  (:documentation "recurse on TREE during a call to `HINDLEY-MILNER/SUBST:SUBST'"))

(defmethod subst-recurse (new old tree test)
  "the default, non-recursive method, which returns TREE"
  (declare (ignorable new old test))
  tree)

(defmacro define-subst (class-name &body body)
  "define how `HINDLEY-MINLER/SUBST:SUBST' should recurse into instances of CLASS-NAME

CLASS-NAME is bound in BODY to the instance being recursed into (the
TREE argument to `SUBST'), and `RECURSE' is bound to a function of one
argument which passes that argument as TREE to `SUBST'. BODY should
probably be a call to a constructor for CLASS-NAME.

for example, the method for `CONS' is defined as:
  (DEFINE-SUBST CONS
    (CONS (RECURSE (CAR CONS))
          (RECURSE (CDR CONS))))"
  `(defmethod subst-recurse (new old (,class-name ,class-name) test)
     ,(format nil "`SUBST-RECURSE' method for `~s' generated by `DEFINE-SUBST'" class-name)
     (flet ((recurse (value)
              (subst new old value :test test)))
       ,@body)))

(define-subst cons
  (cons (recurse (car cons))
        (recurse (cdr cons))))

(defun subst (new old tree &key (test #'eql))
  "a generic version of `CL:SUBST', capable of recurring on trees other than `CONS'

define recursive methods using `HINDLEY-MILNER/SUBST:DEFINE-SUBST'"
  (if (funcall test old tree)
      new
      (subst-recurse new old tree test)))

(defmacro recurse-on-slots (class-name &body slot-names)
  "define a `SUBST-RECURSE' method for CLASS-NAME which recurses on SLOT-NAMES"
  (let ((slot-gensyms (mapcar #'alexandria:make-gensym slot-names))
        (slot-boundp-gensyms
          (flet ((slot-boundp-gensym (slot-name)
                   (make-gensym (symbol-concatenate slot-name '-boundp))))
            (mapcar #'slot-boundp-gensym slot-names))))
    (flet ((slot-boundp-binding-pair (slot-name slot-boundp-name)
             `(,slot-boundp-name (slot-boundp instance ',slot-name)))
           (let-binding-pair (slot-name binding-name slot-boundp-name)
             `(,binding-name
               (when ,slot-boundp-name
                 (subst new old (slot-value instance ',slot-name) :test test))))
           (slot-changed-p-form (slot-name binding-name slot-boundp-name)
             `(or (not ,slot-boundp-name)
                  (eq (slot-value instance ',slot-name) ,binding-name)))
           (setf-slot-form (slot-name binding-name slot-boundp-name)
             `(when ,slot-boundp-name
                (setf (slot-value copy ',slot-name) ,binding-name))))
      `(defmethod subst-recurse (new old (instance ,class-name) test)
         ,(format nil "`SUBST-RECURSE' method for `~s' generated by `RECURSE-ON-SLOTS'" class-name)
         (let ,(mapcar #'slot-boundp-binding-pair slot-names slot-boundp-gensyms)
           (let ,(mapcar #'let-binding-pair slot-names slot-gensyms slot-boundp-gensyms)
             (if (and ,@(mapcar #'slot-changed-p-form slot-names slot-gensyms slot-boundp-gensyms))
                 ;; if all the slots are `EQ', no new allocation is needed; substitution is a no-op
                 instance
                 ;; if at least one slot is non-`EQ', allocate a new instance
                 (let ((copy (shallow-copy instance)))
                   ,@(mapcar #'setf-slot-form slot-names slot-gensyms slot-boundp-gensyms)
                   copy))))))))
