(uiop:define-package :hindley-milner/subst
    (:use :cl)
  (:import-from :alexandria :with-gensyms)
  (:nicknames :subst)
  (:shadow :subst)
  (:export :subst :define-subst :recurse :recurse-on-slots))
(cl:in-package :hindley-milner/subst)

(defgeneric subst-recurse (new old tree test)
  (:documentation "recurse on TREE during a call to `HINDLEY-MILNER/SUBST:SUBST'"))

(defmethod subst-recurse (new old tree test)
  "the default, non-recursive method, which returns TREE"
  (declare (ignorable new old test))
  tree)

(defmacro define-subst (class-name &body body)
  "define how `HINDLEY-MINLER/SUBST:SUBST' should recurse into instances of CLASS-NAME

CLASS-NAME is bound in BODY to the instance being recursed into (the
TREE argument to `SUBST'), and `RECURSE' is bound to a function of one
argument which passes that argument as TREE to `SUBST'. BODY should
probably be a call to a constructor for CLASS-NAME.

for example, the method for `CONS' is defined as:
  (DEFINE-SUBST CONS
    (CONS (RECURSE (CAR CONS))
          (RECURSE (CDR CONS))))"
  `(defmethod subst-recurse (new old (,class-name ,class-name) test)
     ,(format nil "`SUBST-RECURSE' method for `~s' generated by `DEFINE-SUBST'" class-name)
     (flet ((recurse (value)
              (subst new old value :test test)))
       ,@body)))

(define-subst cons
  (cons (recurse (car cons))
        (recurse (cdr cons))))

(defun subst (new old tree &key (test #'eql))
  "a generic version of `CL:SUBST', capable of recurring on trees other than `CONS'

define recursive methods using `HINDLEY-MILNER/SUBST:DEFINE-SUBST'"
  (if (funcall test old tree)
      new
      (subst-recurse new old tree test)))

(defmacro recurse-on-slots (class-name &body slot-names)
  "define a `SUBST-RECURSE' method for CLASS-NAME which recurses on SLOT-NAMES"
  (let ((slot-gensyms (mapcar #'alexandria:make-gensym slot-names)))
    (flet ((let-binding-pair (slot-name binding-name)
             `(,binding-name (subst new old (slot-value instance ',slot-name) :test test)))
           (slot-eq-form (slot-name binding-name)
             `(eq (slot-value instance ',slot-name) ,binding-name))
           (setf-slot-form (slot-name binding-name)
             `(setf (slot-value copy ',slot-name) ,binding-name)))
      `(defmethod subst-recurse (new old (instance ,class-name) test)
         ,(format nil "`SUBST-RECURSE' method for `~s' generated by `RECURSE-ON-SLOTS'" class-name)
         (let ,(mapcar #'let-binding-pair slot-names slot-gensyms)
           (if (and ,@(mapcar #'slot-eq-form slot-names slot-gensyms))
               ;; if all the slots are `EQ', no new allocation is needed; substitution is a no-op
               instance
               ;; if at least one slot is non-`EQ', allocate a new instance
               (let ((copy (gefjon-utils:shallow-copy instance)))
                 ,@(mapcar #'setf-slot-form slot-names slot-gensyms)
                 copy)))))))
