(uiop:define-package :hindley-milner/subst
    (:use :cl)
  (:import-from :alexandria :with-gensyms)
  (:nicknames :subst)
  (:shadow :subst)
  (:export :subst :define-subst :recurse :defstruct-with-subst))
(cl:in-package :hindley-milner/subst)

(defgeneric subst-recurse (new old tree test)
  (:documentation "recurse on TREE during a call to `HINDLEY-MILNER/SUBST:SUBST'"))

(defmethod subst-recurse (new old tree test)
  "the default, non-recursive method, which returns TREE"
  (declare (ignorable new old test))
  tree)

(defmacro define-subst (class-name &body body)
  "define how `HINDLEY-MINLER/SUBST:SUBST' should recurse into instances of CLASS-NAME

CLASS-NAME is bound in BODY to the instance being recursed into (the
TREE argument to `SUBST'), and `RECURSE' is bound to a function of one
argument which passes that argument as TREE to `SUBST'. BODY should
probably be a call to a constructor for CLASS-NAME.

for example, the method for `CONS' is defined as:
  (DEFINE-SUBST CONS
    (CONS (RECURSE (CAR CONS))
          (RECURSE (CDR CONS))))"
  (with-gensyms (value)
    `(defmethod subst-recurse (new old (,class-name ,class-name) test)
       ,(format nil "`SUBST-RECURSE' method for `~s' generated by `DEFINE-SUBST'" class-name)
       (flet ((recurse (,value)
                (subst new old ,value :test test)))
         ,@body))))

(define-subst cons
  (cons (recurse (car cons))
        (recurse (cdr cons))))

(defun subst (new old tree &key (test #'eql))
  "a generic version of `CL:SUBST', capable of recurring on trees other than `CONS'

define recursive methods using `HINDLEY-MILNER/SUBST:DEFINE-SUBST'"
  (if (funcall test old tree)
      new
      (subst-recurse new old tree test)))

(defmacro derive-define-subst-for-struct (class constructor slots)
  "generate a `DEFINE-SUBST' form for CLASS which recurses on the values of SLOTS

SLOTS should be a list of symbols which name slots of CLASS"
  (flet ((recurse-form (slot)
           `(recurse ,slot)))
    `(define-subst ,class
       (with-slots ,slots ,class
         (,constructor ,@(mapcar #'recurse-form slots))))))

(defmacro defstruct-with-subst (name slots)
  "like `GEFJON-UTILS:DEFSTRUCT', but also generates a method for `HINDLEY-MILNER/SUBST:SUBST-RECURSE'"
  `(prog1 (gefjon-utils:defstruct ,name ,slots)
     (derive-define-subst-for-struct ,name
                                     ,(gefjon-utils:constructor-name name)
                                     ,(mapcar #'first slots))))


