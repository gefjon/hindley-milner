(uiop:define-package :hindley-milner/prologue/clos
  (:mix :cl :iterate)
  (:import-from :alexandria
   :symbolicate :remove-from-plist)
  (:import-from :closer-mop
   :class-slots
   :slot-definition-name)
  (:export
   :define-class
   :define-enum
   :shallow-copy
   :map-slots
   :with-slot-accessors))
(in-package :hindley-milner/prologue/clos)

(defmacro err-uninit (slot-name)
  `(error "required field uninit: ~s" ',slot-name))

(defstruct slot-descriptor
  (name (err-uninit name) :type symbol)
  (type (err-uninit type))
  (may-init-unbound nil :type boolean)
  (initform (err-uninit initform))
  (initarg (err-uninit initarg) :type (or null keyword))
  (accessor (err-uninit accessor) :type symbol)
  (read-only nil :type boolean))

(defun coerce-to-string (object)
  (typecase object
    (symbol (symbol-name object))
    (string object)
    (t (coerce object 'string))))

(defun make-keyword (symbol-or-string)
  (intern (coerce-to-string symbol-or-string)
          (find-package :keyword)))

(defun parse-slot-descriptor (list)
  (destructuring-bind (name type &key may-init-unbound
                                   (initform `(err-uninit ,name) initform-supplied-p)
                                   (initarg (make-keyword name))
                                   (accessor name)
                                   read-only)
      list
    (when (and may-init-unbound initform-supplied-p)
      (error "initform and may-init-unbound are mutually exclusive"))
    (when (and read-only (not accessor))
      (error ":READ-ONLY T is incompatible with :ACCESSOR NIL"))
    (make-slot-descriptor :name name
                            :type type
                            :may-init-unbound may-init-unbound
                            :initform initform
                            :initarg initarg
                            :accessor accessor
                            :read-only read-only)))

(defun output-slot-descriptor (slot-descriptor)
  "build a slot-specifier suitable for `CL:DEFCLASS'"
  (with-slots (name type may-init-unbound initform initarg accessor read-only) slot-descriptor
    `(,name
      :type ,type
      ,@(unless may-init-unbound
          `(:initform ,initform))
      ,@(when initarg
          `(:initarg ,initarg))
      ,@(when accessor
          `(,(if read-only :reader :accessor) ,accessor)))))

(defun slot-boundp-forms (class-name slot-descriptors)
  (labels ((boundp-name (slot-name)
             (symbolicate class-name '- slot-name '-boundp))
           (defboundp (slot-descriptor)
             (with-slots (name) slot-descriptor
               `(progn
                  (declaim (ftype (function (,class-name) boolean)
                                  ,(boundp-name name)))
                  (defun ,(boundp-name name) (instance)
                    (slot-boundp instance ',name))))))
    `(progn ,@(mapcar #'defboundp
                      (remove-if-not #'slot-descriptor-may-init-unbound slot-descriptors)))))

(defmacro define-class (class-name slot-descriptors &key (documentation "generated by `hindley-milner/prologue/clos:define-class'")
                                                  superclasses)
  "an altpernate syntax for `cl:defclass'.

arranges for a `print-object' method which prints all the present
slots of the instance, including inherited slots.

each SLOT-DESCRIPTOR should be a list of the form
 (SLOT-NAME SLOT-TYPE &key MAY-INIT-UNBOUND INITFORM INITARG ACCESSOR
READ-ONLY). the new class will have a slot named SLOT-NAME with a
declared type of SLOT-TYPE.

if MAY-INIT-UNBOUND is `T', the slot will be
uninitialized until/unless set either by passing INITARG to
`make-instance' or using (`setf' ACCESSOR).

if INITFORM is supplied, its value will be the slot's default
initform, unless overridden by passing INITARG to
`make-instance'. INITFORM and MAY-INIT-UNBOUUND are incompatible.

INITARG should be a keyword or `NIL'. it defaults to the name of the slot
converted to a keyword. if INITARG is supplied and NIL, there will be
no way to initialize the slot while calling `make-instance'.

ACCESSOR should be a symbol. it defaults to SLOT-NAME. if supplied and
NIL, no accessor will be defined.

if READ-ONLY is `T', a reader will be defined instead of an
accessor. the slot will still be writable with (`setf'
`slot-value'). READ-ONLY is incompatible with `:accessor' `NIL'"
  (let ((slot-descriptors (mapcar  #'parse-slot-descriptor slot-descriptors))
        (superclasses (append superclasses
                              '(print-all-slots-mixin load-form-all-slots-mixin))))
    `(progn
       (defclass ,class-name ,superclasses
         ,(mapcar #'output-slot-descriptor slot-descriptors)
         (:documentation ,documentation))
       ,(slot-boundp-forms class-name
                           slot-descriptors))))


(defmacro define-enum (type-name common-slots variants &rest define-class-options)
  "define an enum or sum type named TYPE-NAME with COMMON-SLOTS.

this compiles into a superclass TYPE-NAME and a subtype for each of
the VARIANTS. it's likely incorrect to do (`MAKE-INSTANCE'
'TYPE-NAME), since TYPE-NAME is intended to be an abstract
superclass.

VARIANTS should be a list of variant-descriptors, each of which is a
list of the form (VARIANT-NAME UNIQUE-SLOTS).

UNIQUE-SLOTS is a list of slot-descriptors, each of which is a list of
the form (SLOT-NAME SLOT-TYPE `&KEY' INITFORM MAY-INIT-UNBOUND
ACCESSOR). the `&KEY' args all have sensible defaults."
  `(progn (define-class ,type-name ,common-slots ,@define-class-options)
          (extend-enum ,type-name ,variants)))

(defmacro extend-enum (enum-name variants)
  "add additional VARIANTS to an already-defined enum ENUM-NAME.

this just defines subclasses of ENUM-NAME."
  (flet ((define-variant (variant)
           (destructuring-bind (variant-name unique-slots
                                &rest options &key superclasses &allow-other-keys)
               variant
             `(define-class ,variant-name
                ,unique-slots
                ;; put declared superclasses before the enum class, to
                ;; allow mixins on variants which supersede methods
                ;; from the enum class.
                :superclasses (,@superclasses ,enum-name)
                ,@(remove-from-plist options :superclasses)))))
    `(progn
       ,@(mapcar #'define-variant variants))))

(defmacro skip-nil (var)
  "an ITERATE clause. skip iterations where VAR is NIL."
  `(unless ,var
     (next-iteration)))

(defmacro-driver (for |var| slot-name-of |instance| &optional
                      bound-only |bound-only-p|
                      with-class |class-name|
                      with-slot-definition |slot-definition|)
  "symbols which name slots of a clos instance"
  (let ((class (or |class-name| (gensym "CLASS")))
        (slot-definition (or |slot-definition| (gensym "SLOT-DEFINITION")))
        (bound-only-p (gensym "BOUND-ONLY-P"))
        (instance (gensym "instance"))
        (kwd (if generate 'generate 'for)))
    `(progn
       (with ,instance = ,|instance|)
       (with ,class = (class-of ,instance))
       (with ,bound-only-p = ,|bound-only-p|)
       (generate ,slot-definition in (class-slots ,class))
       (,kwd ,|var| next (do ((name (slot-definition-name (next ,slot-definition))
                                    (slot-definition-name (next ,slot-definition))))
                             ((or (not ,bound-only-p) (slot-boundp ,instance name))
                              name))))))

(defclass print-all-slots-mixin () ()
  (:documentation "a mixin with a `PRINT-OBJECT' method that prints all its slots"))

(defmethod print-object ((object print-all-slots-mixin) stream)
  "print all the slots of OBJECT in the same format as for a `STRUCTURE-OBJECT'"
  (pprint-logical-block (stream nil)
    (print-unreadable-object (object stream :type nil :identity nil)
      ;; i manually print the name of the class rather than passing
      ;; `:type t' to `PRINT-UNREADABLE-OBJECT' because i don't like
      ;; the extra clutter of the package designator
      (write-string (symbol-name (class-name (class-of object))) stream)
      (pprint-logical-block (stream nil)
        (iter
          (for slot-name slot-name-of object bound-only t)
          (unless (first-time-p)
            (pprint-newline :linear stream))
          (write-char #\space stream)
          (format stream ":~a ~s" slot-name (slot-value object slot-name)))))))

(defclass load-form-all-slots-mixin () ()
  (:documentation "a mixin with a `make-load-form' method which calls `make-load-form-saving-slots'."))

(defmethod make-load-form ((object load-form-all-slots-mixin) &optional env)
  (make-load-form-saving-slots object :environment env))

(defgeneric shallow-copy (object &rest initargs &key &allow-other-keys)
  (:documentation "Makes and returns a shallow copy of OBJECT."))

(defmethod shallow-copy ((object standard-object) &rest initargs &key &allow-other-keys)
  "Shallow copy a CLOS instance.

An uninitialized object of the same class as OBJECT is allocated by
calling ALLOCATE-INSTANCE.  For all slots returned by CLASS-SLOTS, the
returned object has the same slot values and slot-unbound status as
OBJECT.

REINITIALIZE-INSTANCE is called to update the copy with INITARGS.

from https://stackoverflow.com/questions/11067899/is-there-a-generic-method-for-cloning-clos-objects"
  (iter
    (with copy = (allocate-instance (class-of object)))
    (for slot-name slot-name-of object bound-only t)
    (setf (slot-value copy slot-name)
          (slot-value object slot-name))
    (finally
     (return (apply #'reinitialize-instance copy initargs)))))

(defun map-slots (func object &rest other-objects)
  "Construct a new instance of the same class as OBJECT whose slots are filled with the result of applying FUNC to the values of those slots in OBJECT and OTHER-OBJECTS."
  (iter
    (for slot-name slot-name-of object
         bound-only t
         with-class class)
    (with new = (allocate-instance class))
    (flet ((slot-val (instance) (slot-value instance slot-name)))
      (setf (slot-value new slot-name)
            (apply func (slot-val object) (mapcar #'slot-val other-objects))))
    (finally (return new))))

(defmacro with-slot-accessors (accessors instance &body body)
  "Like `with-accessors', but allows the shorthand from `with-slots' which binds the name of the accessor as the local."
  (flet ((canonicalize (accessor)
           (etypecase accessor
             ((cons symbol (cons symbol null)) accessor)
             (symbol `(,accessor ,accessor)))))
    `(with-accessors ,(mapcar #'canonicalize accessors) ,instance ,@body)))
