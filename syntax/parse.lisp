(uiop:define-package :hindley-milner/syntax/parse
  (:mix
   :hindley-milner/prologue
   :hindley-milner/syntax/clause
   :iterate
   :cl)
  (:import-from :trivial-types
   :proper-list)
  (:import-from :alexandria
   :destructuring-ecase)
  (:export
   :parse :parse-top-level-form))
(cl:in-package :hindley-milner/syntax/parse)

(defgeneric parse (thing)
  (:documentation "parse an object produced by `READ' into a `SYNTAX:CLAUSE'"))

(defgeneric parse-list (head &rest stuff)
  (:documentation "intended to be `CL:APPLY'ed to a `TRIVIAL-TYPES:PROPER-LIST'"))

(defmethod parse ((thing cons))
  (apply #'parse-list thing))

(|:| #'parse-body (-> (list) (vector clause)))
(defun parse-body (body)
  (iter (for clause in body)
    (collect (parse clause) result-type (vector clause))))

(defgeneric parse-top-level-form (head &rest tail))

(defmacro define-top-level-form ((head &rest args) &body body)
  (with-gensyms (head-arg tail-arg)
    `(defmethod parse-top-level-form ((,head-arg (eql ',head)) &rest ,tail-arg)
       (declare (ignorable ,head-arg))
       (destructuring-bind ,args ,tail-arg
         ,@body))))

(define-top-level-form (hm:|const| name value)
  (make-instance 'const :binding name :value (parse value)))

(|:| #'type-name-and-params (-> ((or cons symbol))
                                (values symbol (proper-list symbol))))
(defun type-name-and-params (typespec)
  (etypecase typespec
    (cons (destructuring-bind (name &rest params) typespec
            (values name params)))
    (symbol (values typespec ()))))

(define-top-level-form (hm:|struct| name &rest fields)
  (multiple-value-bind (name params) (type-name-and-params name)
    (make-instance 'struct
                   :name name
                   :type-params (coerce params '(vector symbol))
                   :elts (coerce fields '(vector symbol)))))

(define-top-level-form (hm:|enum| name &rest variants)
  (flet ((parse-variant (variant)
           (apply #'parse-top-level-form 'hm:|struct| (etypecase variant
                                                        (list variant)
                                                        (symbol (list variant))))))
    (multiple-value-bind (name params) (type-name-and-params name)
      (make-instance 'enum
                     :name name
                     :type-params params
                     :variants (map '(vector struct) #'parse-variant variants)))))

(define-top-level-form (hm:|fn| name arglist &body body)
  (make-instance 'fn
                 :name name
                 :value (make-instance 'lambda
                                       :bindings (coerce arglist '(vector symbol))
                                       :body (parse-body body))))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun get-hm-symbol (symbol)
    "return a symbol that is like SYMBOL, but downcased and interend in `:HM'"
    (intern (string-downcase (symbol-name symbol))
            (find-package :hm))))

(defmacro define-parser (head lambda-list &body body)
  "define a parser for lists starting with HEAD and continuing with LAMBDA-LIST

e.g. (define-parser funcall (function &rest args)
       (make-instance 'funcall
                      :func (parse function)
                      :args (mapcar #'parse args)))"
  (cl:let ((head (get-hm-symbol head)))
    (with-gensyms (head-arg stuff-arg)
      `(defmethod parse-list ((,head-arg (eql ',head)) &rest ,stuff-arg)
         (declare (ignorable ,head-arg))
         ,(format nil "parser for ~s generated by `HINDLEY-MILNER/SYNTAX:DEFINE-PARSER'" head)
         (destructuring-bind ,lambda-list ,stuff-arg
           ,@body)))))

(defmethod parse ((thing (eql 'hm:|true|)))
  (declare (ignorable thing))
  (make-instance 'quote :it t))
(defmethod parse ((thing (eql 'hm:|false|)))
  (declare (ignorable thing))
  (make-instance 'quote :it nil))
(defmethod parse ((thing fixnum))
  (make-instance 'quote :it thing))
(defmethod parse ((symbol symbol))
  (make-instance 'variable :name symbol))

(defmethod parse-list ((head symbol) &rest args)
  "fallthrough method for named funcalls, so that (foo bar baz) parses as (funcall foo bar baz)"
  (cl:if (typep head 'primop:operator)
         (make-instance 'primop
                        :op head
                        :args (parse-body args))
         (make-instance 'funcall
                        :func (parse head)
                        :args (parse-body args))))

(define-parser funcall (function &rest args)
  (make-instance 'funcall
                 :func (parse function)
                 :arg (parse-body args)))

(define-parser lambda (lambda-list &body body)
  (flet ((check-symbol (symbol)
           (unless (typep symbol 'symbol)
             (error "non-symbol ~s in `LAMBDA-LIST'" symbol))
           symbol))
    (make-instance 'lambda
                   :bindings (map '(vector symbol) #'check-symbol lambda-list)
                   :body (parse-body body))))

(define-parser let (bindings &body body)
  (flet ((parse-binding (binding)
           (destructuring-bind (symbol value) binding
             (check-type symbol symbol)
             (make-instance 'const
                            :binding symbol
                            :value (parse value)))))
    (make-instance 'let
                   :bindings (map '(vector const) #'parse-binding bindings)
                   :body (parse-body body))))

(define-parser if (predicate then-clause else-clause)
  (make-instance 'if
                 :predicate (parse predicate)
                 :then-case (parse then-clause)
                 :else-case (parse else-clause)))

(defgeneric parse-pattern (pattern))

(|:| #'parse-match-arm (-> (list) (cons pattern clause)))
(defun parse-match-arm (arm)
  (destructuring-bind (pattern clause) arm
    (cons (parse-pattern pattern)
          (parse clause))))

(define-parser match (value &rest arms)
  (make-instance 'match
                 :val (parse value)
                 :arms (map '(vector (cons pattern clause)) #'parse-match-arm
                            arms)))

(defmethod parse-pattern ((destruct cons))
  (destructuring-bind (discrim &rest pats) destruct
    (make-instance 'destruct
                   :name discrim
                   :elts (map '(vector pattern)
                              #'parse-pattern
                              pats))))

(defmethod parse-pattern ((_ (eql 'hm:_)))
  (declare (ignorable _))
  (make-instance 'ign))

(defmethod parse-pattern ((bind symbol))
  (make-instance 'bind :name bind))

(defmethod parse-pattern ((exactly fixnum))
  (make-instance 'exactly :name exactly))

(defmethod parse-pattern ((exactly (eql 'hm:|true|)))
  (declare (ignorable exactly))
  (make-instance 'exactly :value t))

(defmethod parse-pattern ((exactly (eql 'hm:|false|)))
  (declare (ignorable exactly))
  (make-instance 'exactly :value nil))
